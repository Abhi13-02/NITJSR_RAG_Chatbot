<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NIT Jamshedpur RAG Chatbot</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="chat-container">
    <div class="chat-header">
        <img src="./assets/logo.png" alt="NIT Jamshedpur Logo" class="chat-header-logo">
        <div class="chat-header-text">
            <h1>NIT Jamshedpur Chatbot</h1>
            <p>Powered by LangChain & Pinecone Vector Database</p>
        </div>
    </div>

    <div class="status-bar">
        <div class="status-left">
            <div class="status-indicator">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Connecting...</span>
            </div>
            <div class="vector-stats" id="vector-stats">
                Vector DB: Initializing...
            </div>
        </div>
        <div class="status-actions">
            <button class="btn-small" onclick="app.refreshData()">Refresh</button>
            <button class="btn-small" onclick="app.showStats()">Statistics</button>
            <button class="btn-small" onclick="app.showSources()">Sources</button>
        </div>
    </div>

    <div class="chat-messages" id="chat-messages">
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <p>Initializing RAG system...</p>
            <p style="font-size: 12px; margin-top: 12px; opacity: 0.7;">Loading embeddings and vector database...</p>
        </div>
    </div>

    <div class="typing-indicator" id="typing-indicator">
        <span>Processing your query</span>
        <div class="typing-dots">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </div>

    <div class="quick-questions">
        <h4>Quick Questions</h4>
        <div class="question-pills">
            <div class="question-pill" onclick="app.askQuestion('Tell me about NIT Jamshedpur?')">About NITJSR</div>
            <div class="question-pill" onclick="app.askQuestion('How to reach NIT Jamshedpur?')">Location</div>
            <div class="question-pill" onclick="app.askQuestion('Tell me about hostel facilities in NIT Jamshedpur?')">Hostel Facilities</div>
            <div class="question-pill" onclick="app.askQuestion('What is the NIRF Ranking of NIT Jamshedpur?')">Ranking</div>
            <div class="question-pill" onclick="app.askQuestion('Tell me about the wardens of NIT Jamshedpur?')">Warden</div>
        </div>
    </div>

    <div class="chat-input-container">
        <input
                type="text"
                id="chat-input"
                class="chat-input"
                placeholder="Ask about placements, packages, companies, statistics..."
        >
        <button id="send-button" class="send-button" onclick="app.sendMessage()">Send</button>
    </div>
</div>

<script type="module">
    // API Communication Module
    const API_BASE = (() => {
        // Allow manual override if window.API_BASE is set
        if (typeof window !== 'undefined' && window.API_BASE) return window.API_BASE;

        // If the page is opened via a static dev server on 127.0.0.1 (e.g., Live Server),
        // direct API to the Node server bound on localhost.
        if (location.hostname === '127.0.0.1') {
            return 'http://localhost:5500';
        }

        // Otherwise use relative paths (same-origin) when served by the Node server itself
        return '';
    })();
    const DISABLE_AUTO_INIT = (() => {
        try {
            const q = new URLSearchParams(location.search);
            if (q.get('noinit') === '1') return true;
            return Boolean(window.DISABLE_AUTO_INIT);
        } catch (_) { return false; }
    })();

    const API = {
        async healthCheck() {
            const response = await fetch(`${API_BASE}/health`);
            return await response.json();
        },

        async initialize() {
            const response = await fetch(`${API_BASE}/initialize`, { method: 'POST' });
            return await response.json();
        },

        async sendMessage(question) {
            const response = await fetch(`${API_BASE}/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ question })
            });
            return await response.json();
        },

        async scrapeData(force = true) {
            const response = await fetch(`${API_BASE}/scrape`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ force })
            });
            return await response.json();
        },

        async getStatistics() {
            const response = await fetch(`${API_BASE}/stats`);
            return await response.json();
        },

        async getSources() {
            const response = await fetch(`${API_BASE}/sources`);
            return await response.json();
        }
    };

    // UI Management Module
    const UI = {
        elements: {},

        init() {
            this.elements.statusDot = document.getElementById('status-dot');
            this.elements.statusText = document.getElementById('status-text');
            this.elements.vectorStats = document.getElementById('vector-stats');
            this.elements.loading = document.getElementById('loading');
            this.elements.chatMessages = document.getElementById('chat-messages');
            this.elements.typingIndicator = document.getElementById('typing-indicator');
            this.elements.chatInput = document.getElementById('chat-input');
            this.elements.sendButton = document.getElementById('send-button');
        },

        updateStatus(status, text) {
            this.elements.statusDot.className = `status-dot ${status}`;
            this.elements.statusText.textContent = text;
        },

        updateVectorStats(stats) {
            if (stats && stats.totalVectors !== undefined) {
                this.elements.vectorStats.textContent = `Vector DB: ${stats.totalVectors} documents`;
            }
        },

        hideLoading() {
            this.elements.loading.style.display = 'none';
        },

        showErrorMessage(error = 'Unknown error') {
            this.elements.loading.innerHTML = `
                <div class="error-message">
                    <h3>Connection Failed</h3>
                    <p>Could not connect to the RAG server.</p>
                    <p><strong>Error:</strong> ${error}</p>
                    <p style="margin-top: 12px; font-size: 12px;">
                        Please ensure the server is running and try refreshing the page.
                    </p>
                </div>
            `;
        },

        showTyping() {
            this.elements.typingIndicator.style.display = 'flex';
        },

        hideTyping() {
            this.elements.typingIndicator.style.display = 'none';
        },

        enableInput() {
            this.elements.sendButton.disabled = false;
            this.elements.chatInput.disabled = false;
        },

        disableInput() {
            this.elements.sendButton.disabled = true;
            this.elements.chatInput.disabled = true;
        },

        clearInput() {
            this.elements.chatInput.value = '';
        },

        getInputValue() {
            return this.elements.chatInput.value.trim();
        },

        setInputValue(value) {
            this.elements.chatInput.value = value;
        },

        addMessage(sender, content, sources = [], confidence = 0, timestamp = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;

            const avatar = sender === 'bot' ? 'AI' : 'U';

            let confidenceHTML = '';
            if (sender === 'bot' && confidence > 0) {
                const confidencePercent = Math.round(confidence * 100);
                let confidenceClass = 'low';
                if (confidence > 0.8) confidenceClass = 'high';
                else if (confidence > 0.6) confidenceClass = 'medium';

                confidenceHTML = `
                    <div class="message-metadata">
                        <span>Response generated at ${timestamp ? new Date(timestamp).toLocaleTimeString() : new Date().toLocaleTimeString()}</span>
                        <span class="confidence-score ${confidenceClass}">
                            Confidence: ${confidencePercent}%
                        </span>
                    </div>
                `;
            }

            let sourcesHTML = '';
            if (sources && sources.length > 0) {
                sourcesHTML = `
                    <div class="message-sources">
                        <strong>Sources (${sources.length}):</strong><br>
                        ${sources.map((source, index) =>
                    `<a href="${source.url || '#'}" class="source-link" target="_blank" title="${source.text || ''}">
                                ${index + 1}. ${source.source || source.title || 'Document'}
                                ${source.score ? `(${Math.round(source.score * 100)}% match)` : ''}
                            </a>`
                ).join('')}
                    </div>
                `;
            }

            const formattedContent = sender === 'bot' ? this.formatResponse(content) : content.replace(/\n/g, '<br>');

            messageDiv.innerHTML = `
                <div class="message-avatar">${avatar}</div>
                <div class="message-content">
                    ${formattedContent}
                    ${sourcesHTML}
                    ${confidenceHTML}
                </div>
            `;

            this.elements.chatMessages.appendChild(messageDiv);
            this.scrollToBottom();
        },

        scrollToBottom() {
            this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
        },

        formatResponse(text) {
            text = text.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            text = text.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            let lines = text.split('\n');
            let inList = false;
            let formattedLines = [];
            
            for (let line of lines) {
                if (line.trim().match(/^\* /)) {
                    if (!inList) {
                        formattedLines.push('<ul>');
                        inList = true;
                    }
                    formattedLines.push('<li>' + line.trim().substring(2) + '</li>');
                } else {
                    if (inList) {
                        formattedLines.push('</ul>');
                        inList = false;
                    }
                    if (line.trim()) {
                        formattedLines.push('<p>' + line + '</p>');
                    }
                }
            }
            
            if (inList) formattedLines.push('</ul>');
            
            return formattedLines.join('\n').replace(/<p>\s*<\/p>/g, '');
        }
    };

    // State Management Module
    const State = {
        isInitialized: false,
        isLoading: false,
        systemStats: null,

        setInitialized(value) {
            this.isInitialized = value;
        },

        setLoading(value) {
            this.isLoading = value;
        },

        setSystemStats(stats) {
            this.systemStats = stats;
        },

        getInitialized() {
            return this.isInitialized;
        },

        getLoading() {
            return this.isLoading;
        },

        getSystemStats() {
            return this.systemStats;
        }
    };

    // Message Templates Module
    const Messages = {
        welcome() {
            return `Welcome to the NIT Jamshedpur Placement Assistant.

This system is powered by advanced AI technologies including LangChain for intelligent processing, Pinecone vector database for semantic search, real-time web scraping for latest data, and PDF document analysis.

I can help you with:
• Placement statistics and percentages
• Package information (highest, average, branch-wise)
• Company details and recruitment patterns
• Branch-specific placement data
• Historical trends and analysis

Please ask me anything about NIT Jamshedpur placements.`;
        },

        dataRefreshSuccess(summary, timestamp) {
            return `Data refresh completed successfully.

Summary:
• ${summary.totalPages} web pages processed
• ${summary.totalPDFs} PDF documents analyzed
• ${summary.totalLinks} links discovered
• Updated at: ${new Date(timestamp).toLocaleString()}

I now have the latest placement information.`;
        },

        dataRefreshError() {
            return 'Failed to refresh data. Using existing information.';
        },

        statistics(stats) {
            return `System Statistics:

Server Status:
• Uptime: ${Math.round(stats.serverUptime / 3600)} hours
• Node.js: ${stats.nodeVersion}
• Environment: ${stats.nodeVersion}

Vector Database:
• Total documents: ${stats.vectorDatabase.totalVectors || 0}
• Database fullness: ${Math.round((stats.vectorDatabase.indexFullness || 0) * 100)}%
• Dimension: ${stats.vectorDatabase.dimension || 'N/A'}

Data Sources:
• Scraped data files: ${stats.scrapedDataFiles}
• Latest file: ${stats.latestDataFile}
• System initialized: ${stats.initialized ? 'Yes' : 'No'}

Last updated: ${new Date(stats.timestamp).toLocaleString()}`;
        },

        statisticsError() {
            return 'Failed to retrieve system statistics.';
        },

        sources(sources) {
            const sourcesText = sources.map((source, index) =>
                `${index + 1}. ${source.filename}
   • Scraped: ${new Date(source.timestamp).toLocaleString()}
   • Pages: ${source.pagesScraped}, PDFs: ${source.pdfsProcessed}
   • Links: ${source.linksFound}`
            ).join('\n\n');

            return `Available Data Sources:

${sourcesText}

These sources contain placement data including statistics, company information, package details, and historical trends.`;
        },

        noSources() {
            return 'No data sources found. Try refreshing the data first.';
        },

        sourcesError() {
            return 'Failed to retrieve data sources.';
        },

        connectionError(error) {
            return `Sorry, I encountered an error: ${error}`;
        },

        requestError() {
            return 'Sorry, I could not process your request. Please check your connection and try again.';
        }
    };

    // Main Application Module
    const App = {
        async init() {
            UI.init();
            await this.initializeChat();
            this.setupEventListeners();
            this.startHealthCheckInterval();
        },

        async initializeChat() {
            try {
                const data = await API.healthCheck();

                if (data.status === 'healthy') {
                    UI.updateStatus('online', 'Connected');
                    UI.updateVectorStats(data.vectorDatabase);

                    if (!data.initialized && !DISABLE_AUTO_INIT) {
                        UI.updateStatus('initializing', 'Initializing RAG system...');
                        const initData = await API.initialize();

                        if (initData.success) {
                            UI.updateStatus('online', 'Ready');
                        } else {
                            throw new Error(initData.error);
                        }
                    } else if (!data.initialized && DISABLE_AUTO_INIT) {
                        UI.updateStatus('idle', 'Server not initialized');
                    }

                    State.setInitialized(true);
                    UI.hideLoading();
                    UI.addMessage('bot', Messages.welcome(), [], 1.0, new Date().toISOString());
                } else {
                    throw new Error(data.error || 'Server unhealthy');
                }
            } catch (error) {
                console.error('Failed to connect:', error);
                UI.updateStatus('offline', 'Connection Failed');
                UI.showErrorMessage(error.message);
            }
        },

        setupEventListeners() {
            const input = UI.elements.chatInput;
            input.addEventListener('keypress', (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    this.sendMessage();
                }
            });
        },

        async sendMessage() {
            if (State.getLoading() || !State.getInitialized()) return;

            const message = UI.getInputValue();
            if (!message) return;

            UI.addMessage('user', message);
            UI.clearInput();
            UI.showTyping();
            State.setLoading(true);
            UI.disableInput();

            try {
                const data = await API.sendMessage(message);

                if (data.success) {
                    UI.addMessage('bot', data.answer, data.sources, data.confidence, data.timestamp);
                } else {
                    UI.addMessage('bot', Messages.connectionError(data.error));
                }
            } catch (error) {
                console.error('Error sending message:', error);
                UI.addMessage('bot', Messages.requestError());
            } finally {
                UI.hideTyping();
                State.setLoading(false);
                UI.enableInput();
            }
        },

        askQuestion(question) {
            UI.setInputValue(question);
            this.sendMessage();
        },

        async refreshData() {
            if (State.getLoading()) return;

            UI.updateStatus('initializing', 'Refreshing data...');

            try {
                const data = await API.scrapeData(true);

                if (data.success) {
                    UI.updateStatus('online', 'Ready');
                    UI.addMessage('bot', Messages.dataRefreshSuccess(data.summary, data.timestamp));
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                console.error('Error refreshing data:', error);
                UI.updateStatus('online', 'Ready');
                UI.addMessage('bot', Messages.dataRefreshError());
            }
        },

        async showStats() {
            try {
                const data = await API.getStatistics();

                if (data.success) {
                    UI.addMessage('bot', Messages.statistics(data.statistics));
                }
            } catch (error) {
                UI.addMessage('bot', Messages.statisticsError());
            }
        },

        async showSources() {
            try {
                const data = await API.getSources();

                if (data.success && data.sources.length > 0) {
                    UI.addMessage('bot', Messages.sources(data.sources));
                } else {
                    UI.addMessage('bot', Messages.noSources());
                }
            } catch (error) {
                UI.addMessage('bot', Messages.sourcesError());
            }
        },

        startHealthCheckInterval() {
            setInterval(async () => {
                try {
                    const data = await API.healthCheck();
                    UI.updateVectorStats(data.vectorDatabase);
                } catch (error) {
                    console.log('Health check failed:', error.message);
                }
            }, 300000); // 5 minutes
        }
    };

    // Make app globally accessible for inline onclick handlers
    window.app = App;

    // Initialize app when DOM is loaded
    window.addEventListener('load', () => App.init());
</script>
</body>
</html>
